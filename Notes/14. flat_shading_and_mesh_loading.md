Dynamic lighting과 shading에 대해 알아보자.  
![image](https://user-images.githubusercontent.com/63915665/185405323-95773efe-83fc-4723-b250-b5e360dd6510.png)  

3차원 물체에 빛을 쏘아 명암을 입히려 할때, 이를 어떻게 구현할까?  

자세히 살펴보기 전에, 우선 Directional light에 대해 알아보자.  
![image](https://user-images.githubusercontent.com/63915665/185405875-7a0f2257-2c9a-4ade-83de-c1363f2b50e1.png)  
어떤 광원으로부터 쏘아진 광자가 물체에 다다를 때 광원까지의 거리가 멀 수록 물체에 부딪히는 광자들이 이루는 각(여기서는 직선과 표면이 이루는 각)의 크기가 작아짐을 볼 수 있다.  
이는 달리말해 광원의 거리가 무한히 멀다면 이 각이 0도에 수렴하고, 이는 즉 모든 빛이 같은 방향에서 들어온다는 것을 의미한다.  
이러한 빛을 우리는 Directional light이라고 하며, 태양빛과 같이 먼 거리로부터의 빛을 이러한 형태로 나타낼 수 있다.  

그렇다면 이런 Directional light로부터 빛을 받고 있는 어떤 물체 표면의 밝기가 어떻게 결정되는지 그 과정을 살펴보자.  
![image](https://user-images.githubusercontent.com/63915665/185406325-c720c1f8-c891-4800-a5fb-f70c36f7f1b6.png)
당연한 말이지만, 빛의 세기가 셀 수록(광원으로부터 나오는 photon들이 많을 수록) 표면에 맞고 반사되어 눈으로 들어가는 광자의 갯수가 많아지므로 더 밝게 보인다.  

![image](https://user-images.githubusercontent.com/63915665/185406843-262d1231-c20f-4765-9a93-32714e883e92.png)  
이때 표면의 각을 45도로 만들어 광원과 부딪히는 표면적의 면적을 반으로 줄이면 이전에 비해 절반만큼의 광자가 맞고 튕겨져 눈으로 들어오는 것을 알 수 있다. 즉 이전 90도를 이룰 때에 비해 절반만큼 밝다.    
(아예 90도 회전시킬 경우에는 광자에 전혀 맞지 않기 때문에 완전히 어둡게 보인다.)  

즉, 우리는 물체의 표면이 광원으로부터 쏘아져나오는 빛(직선)과 이루는 각도를 바탕으로 그 물체의 밝기를 구할 수 있다.  

![image](https://user-images.githubusercontent.com/63915665/185407264-d3921f74-4e4c-4b30-822b-b62d0a46349f.png)  
이 원리를 이용해 3차원 물체에 밝기에 기반해 색을 입히면 우리 뇌가 3차원 모델을 입체적으로 인식할 수 있게 된다.  

---  

다시 본론으로 들어와서, 원리를 알았으니 이제 이를 구현해보자.  

I를 빛의 세기(intensity)라고 하고 이를 10/m(10만큼의 빛이 meter당 들어온다)라고 나타내자.  
물체의 표면 길이가 1m(편의상 2차원상에 존재하는 1차원 벽면이라 생각하자. 원리는 3차원 표면적에서도 완전히 동일하다.)라고 하고, 빛 방향에 대해 pi/6(30도)만큼 시계방향으로 기울어져 있다고 할 때, 실제로 빛이 부딪히는 물체의 표면적은 1 * sin(pi/6)임을 쉽게 구할 수 있다.  
즉 어떤 표면의 밝기 = I * sin(세타) 라는 일반식을 쉽게 구할 수 있다.  

그런데 sin함수는 컴퓨터 상에선 다소 무거운 함수라는 단점이 있다.  
때문에 우리는 I * sin(세타)를 훨씬 연산이 빠른 벡터의 내적을 활용해 나타낼 것이다.  
dot(v1, v2) = ||v1|| ||v2|| cos(세타)임을 활용해보자. (길이x길이x코사인세타)
우선 빛 방향의 벡터 및 물체 표면의 normal vector(법선벡터)를 모두 normalize해서 길이를 1로 만들면, 이 둘을 내적한 값은 cos(빛과 법선의 각도) 가 된다.  
![image](https://user-images.githubusercontent.com/63915665/185410244-20e11861-e8e1-4ab8-9de5-8542e6d2d6ac.png)  
이때 표면이 빛과 이루는 각도가 세타일 때, 빛과 법선의 각도는 (pi/2 - 세타)로 나타낼 수 있다.  
즉 dot(빛 벡터, 표면의 normal vector) = dot(light,normal) = cos(pi/2 - 세타)이다.  
여기서 놀랍게도 cos(pi/2 - 세타)는 sin(세타)와 값이 동일하다! 때문에 사인 대신 두 벡터의 내적으로 같은 결과값을 얻을 수 있다.

정리하면, I * sin(세타) = I * dot(light,normal)이다!  

![image](https://user-images.githubusercontent.com/63915665/185410821-64b5f6ad-59a8-4154-8e84-3080c4202bfe.png)  
구현할 때 딱 한가지 주의해야 할 점은 normal과 빛이 서로 둔각을 이루기 때문에 우리가 원하는 결과를 얻으려면 한쪽의 방향을 거꾸로 뒤집어야 한다는 점이다. 둘 중 어떤 걸 뒤집던 상관은 없다.  
이걸 뒤집은 다음에 그 뒤집어진 벡터와 기존 벡터를 내적해서 결과를 구해도 되지만, 사실 어떤 둔각의 코사인값을 알면 그 예각의 코사인값은 그 값 * -1이라는 것을 알고 있기 때문에(코사인 그래프를 생각해보면 pi/2지점으로 점대칭이다) 그냥 벡터를 굳이 뒤집지 말고 결과값에만 -1을 곱해주면 된다.  

![image](https://user-images.githubusercontent.com/63915665/185411352-6408a89e-5849-40bb-9727-e582db034974.png)  
때문에 최종적으로는 다음과 같은 일반식이 나온다.  

---  








