Gouraud shading에 대해 알아보자.  
Gouraud shading은 flat shading과 다르게 폴리곤 별로 색상 하나를 지정해주는 방식의 shading이 아니라 모든 폴리곤들에 대해 색을 interpolate 시켜서 부드러운 명암 효과를 줄 수 있다.  
이를 시각적으로 쉽게 알아보기 위해서는 구 오브젝트에 셰이딩을 적용시켜보는 게 가장 직관적인데, 이를 위해 우선 구를 제작해보자.  
![image](https://user-images.githubusercontent.com/63915665/188315125-89bd728f-6516-433b-9421-5bbeb3a583d1.png)
구형 오브젝트를 만드는 방법은 여러가지가 있지만 이번 글에서는 위도와 경도를 이용한 방법을 사용하겠다.  
이 방법을 사용해 일단 모든 정점들을 생성하고 (격자의 교점) 그 정점들이 생성하는 모든 폴리곤들을 점과 맵핑해 생성한 후 위 뚜껑과 아래 뚜껑을 제작하면 구 생성이 종료된다.  
이를 구현하기 위해 우리는 z축(꼭 z가 아니어도 되긴 하다)으로 radius만큼의 길이를 갖는 벡터 하나를 생성해 이 벡터의 각을 변화시키며 회전시켜서 구면을 따라 움직이도록 하면서 점을 찍는 방식으로 구를 생성할 것이다.  
![image](https://user-images.githubusercontent.com/63915665/188315395-78eacfde-bf70-4d59-974e-19e4805e4a1d.png)  
![image](https://user-images.githubusercontent.com/63915665/188315425-68bfc15f-bce9-459b-95f1-5dffdc0fa21d.png)  

이렇게 구현하게 되면 구면의 각 교점들은 위도와 경도, 즉 평면좌표상의 (a,b) 형태로 나타낼 수 있다.  
이 점을 이용해 구면을 구성하는 각 사각형들을 구성하는 두 삼각형의 좌표를 맵핑해 생성할 수 있다.  

```c++
// Sphere.h
#pragma once

#include "Vec3.h"
#include "Mat3.h"
#include "IndexedTriangleList.h"

class Sphere
{
public:
	template<class V>
	static IndexedTriangleList<V> GetPlain( float radius = 1.0f,int latDiv = 12,int longDiv = 24 ) // latDiv와 longDiv는 위도와 경도를 각각 몇 개의 축으로 나눌 지를 나타낸다.
	{
		const Vec3 base = { 0.0f,0.0f,radius }; // 기준이 되는 벡터 생성
		const float lattitudeAngle = PI / latDiv;
		const float longitudeAngle = 2.0f * PI / longDiv;

		std::vector<V> vertices;
		for( int iLat = 1; iLat < latDiv; iLat++ )
		{
			const auto latBase = base * Mat3::RotationX( lattitudeAngle * iLat );
			for( int iLong = 0; iLong < longDiv; iLong++ )
			{
				vertices.emplace_back();
				vertices.back().pos = latBase * Mat3::RotationZ( longitudeAngle * iLong );
			}
		}

		// add the cap vertices (뚜껑 씌우기 위해 NorthPole과 SouthPole의 극점 좌표를 미리 저장해 놓는다.)
		const auto iNorthPole = vertices.size();
		vertices.emplace_back();
		vertices.back().pos = base;
		const auto iSouthPole = vertices.size();
		vertices.emplace_back();
		vertices.back().pos = -base;
		
    // 구면 만들기
		const auto calcIdx = [latDiv,longDiv]( int iLat,int iLong )
			{ return iLat * longDiv + iLong; };
		std::vector<size_t> indices;
		for( int iLat = 0; iLat < latDiv - 2; iLat++ )
		{
			for( int iLong = 0; iLong < longDiv - 1; iLong++ )
			{
				indices.push_back( calcIdx( iLat,iLong ) );
				indices.push_back( calcIdx( iLat + 1,iLong ) );
				indices.push_back( calcIdx( iLat,iLong + 1 ) );
				indices.push_back( calcIdx( iLat,iLong + 1 ) );
				indices.push_back( calcIdx( iLat + 1,iLong ) );
				indices.push_back( calcIdx( iLat + 1,iLong + 1 ) );
			}
      
			// wrap band (옆면 감싸기)
			indices.push_back( calcIdx( iLat,longDiv - 1 ) );
			indices.push_back( calcIdx( iLat + 1,longDiv - 1 ) );
			indices.push_back( calcIdx( iLat,0 ) );
			indices.push_back( calcIdx( iLat,0 ) );
			indices.push_back( calcIdx( iLat + 1,longDiv - 1 ) );
			indices.push_back( calcIdx( iLat + 1,0 ) );			
		}

		// cap fans (뚜껑 씌우기)
		for( int iLong = 0; iLong < longDiv - 1; iLong++ )
		{
			// north
			indices.push_back( iNorthPole );
			indices.push_back( calcIdx( 0,iLong ) );
			indices.push_back( calcIdx( 0,iLong + 1 ) );
			// south
			indices.push_back( calcIdx( latDiv - 2,iLong + 1 ) );
			indices.push_back( calcIdx( latDiv - 2,iLong ) );
			indices.push_back( iSouthPole );
		}
		// wrap triangles (뚜껑의 옆면 감싸기. 뚜껑의 옆면이 비는 이유는 구면의 옆면이 비는 이유와 동일)
		// north
		indices.push_back( iNorthPole );
		indices.push_back( calcIdx( 0,longDiv - 1 ) );
		indices.push_back( calcIdx( 0,0 ) );
		// south
		indices.push_back( calcIdx( latDiv - 2,0 ) );
		indices.push_back( calcIdx( latDiv - 2,longDiv - 1 ) );
		indices.push_back( iSouthPole );


		return{ std::move( vertices ),std::move( indices ) };
	}
	template<class V>
	static IndexedTriangleList<V> GetPlainNormals( float radius = 1.0f,int latDiv = 12,int longDiv = 24 )
	{
		auto sphere = GetPlain<V>( radius,latDiv,longDiv );
		for( auto& v : sphere.vertices )
		{
			v.n = v.pos.GetNormalized();
		}
		return sphere;
	}
};
```

우리는 기준 벡터를 일단 한 번 기울인 상태에서 회전시키기 때문에 위와 아래 양쪽이 뻥 뚫리게 되는 형상이 발생하는데,  
이를 매꾸는 건 원리는 그렇게 어렵지 않다.  
![image](https://user-images.githubusercontent.com/63915665/188315525-47e3eca1-ed39-4ee7-8413-3dba1a4eb98c.png)

완성된 "구"의 모습은 아래와 같다.  
![image](https://user-images.githubusercontent.com/63915665/188315821-87324d90-3708-45bc-aaae-8a5e3a6c82d0.png)

---  

이 구에 명암을 부드럽게 입히려면 어떻게 해야 할까?  
![image](https://user-images.githubusercontent.com/63915665/188315885-009de580-a67f-45cd-81b0-311adc78caee.png)  
단순히 latDiv와 longDiv의 값을 높여 폴리곤 갯수를 늘리는 것도 하나의 방법이지만, 많은 자원이 사용된다는 점에서 당연히 이상적이지는 못한 방법이다.  

![image](https://user-images.githubusercontent.com/63915665/188316122-d488c374-0d11-451f-b5ae-c4d9f13442fe.png)  
이 문제를 해결하기 위해 고안된 것이 바로 Gouraud shading이다.  
어떤 구에 "이상적으로" 명암을 입힌다고 생각해보자.  
구면의 각 점들은 각각의 점의 normal vector에 따라 빛으로부터 얼마만큼의 영향을 받는지가 결정될 텐데,  
이 점의 normal vector는 폴리곤으로 구성된 3D 오브젝트의 각 vertex들의 normal 벡터로도 표현할 수 있다. (사진 참고)  

Gouraud shading에서는 이 점을 이용해 3D 오브젝트 각 정점마다 normal vector를 구하고, 그 구한 normal 벡터에 따라 각 정점에 맞는 색상을 게산한 이후,  
각 정점 사이사이의 빈 공간들은 그 두 정점의 색상 사이를 interpolate하면서 색칠한다.  

![image](https://user-images.githubusercontent.com/63915665/188316222-8816e50f-ec2c-4c54-8551-b8b5a5d59479.png)  
각 정점의 normal vector를 어떻게 구하는지 의문이 들 수도 있는데, 구형 오브젝트의 경우 단순히 중심에서 그 정점까지 벡터를 잇기만 하면 되기 때문에 매우 간단하다.  

그 밖에 색을 interpolate하는 부분이라거나 색을 칠하는 부분은 우리가 이전 학습에서 이미 다 구현해둔 기능들이기 때문에 사실 가져다 사용하기만 하면 된다.  





